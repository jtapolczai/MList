--Haddock-format: http://www.haskell.org/haddock/doc/html/ch03s08.html
--Make documentation: (just once) >cabal configure
--                                >cabal haddock [--executables]
--Make .exe: ghc --make Main.hs

name:          mlist
version:       1.0
build-type:    Simple
cabal-version: >= 1.2
author:        Janos Tapolczai
maintainer:    Janos Tapolczai
stability:     experimental
bug-reports:   mailto:janos.tapolczai@gmail.com
synopsis:      Monadic lists
description:   Provides monadic lists with the constructor @MList m a = MNil | a :# m (MList m a)@,
               allowing for the lazy evaluation of streams of monadic values.

               If a function computes a list of monadic values, where each value depends
               on the previous one, lazy evalution of the list is impossible. A simple example:

               @
               ioSum :: IO [Int]
               ioSum = ioSum' 0
                 where ioSum' acc = do newValue <- getMeasurement
                                       rest <- ioSum' (acc + newValue)
                                       return $ newValue : rest
               @

               ioSum continuously reads in some input and sums the values. We would expect to be able to get, say, the first 10 values of this stream:

               @
               \> ioSum >>= return . take 10
               (endless loop)
               @

               The semantics of >>= of preclude a lazy evaluation of the list: since rest <- ioSum' $ acc + newValue is computed before return $ newValue : rest, ioSum always enters an infinite loop, without returning a single value. This phenomenon occurs as soon as >>= is used, no matter the function's construction. For instance, we could try to rewrite ioSum using fold, but the problem would persist:

               @
               ioSum :: IO [Int]
               ioSum = foldl (\acc i -> do (x:xs) <- acc
                                           i' <- i
                                           return $ (x + i') : x : xs) (return [0]) (repeat getMeasurement)
               @

               @
               \> ioSum >>= return . take 10
               (endless loop)
               @

               We can solve this problem by introducing a modified version of the list, called an MList. Whereas the the list type is List a = Nil | a : (List a), the type of an MList is MList m a = (Monad m) => MNil | a :# m (MList m a). A regular list can only contain monadic computation if its type is [m a] or m [a]. An MList, on the other hand, can limit the monadic computations to its tail, while its pure head can be accessed without problems.

               With MList, we can rewrite the example:

               @
               data MList m a = MNil | a :# m (MList m a)

               takeML :: Monad m => Int -> MList m a -> MList m a
               takeML n xs = ...

               ioSum :: IO (MList IO Int)
               ioSum = ioSum' 0
                 where ioSum' acc = do newValue <- getMeasurement
                                       return $ newValue :# ioSum' (acc + newValue)
               @

               Lazy evaluation now works as intended:

               @
               \> ioSum >>= takeML 10 ioSum
               [3, 9, 24, 46, 88, 90, 93, 121, 452, 530]
               @

category:      Data
license-file:  LICENSE.md

library
   build-depends:   base >= 4.6.0.1
   extensions:      DoAndIfThenElse, EmptyDataDecls, FunctionalDependencies, MultiParamTypeClasses, FlexibleInstances
   exposed-modules: Data.MList